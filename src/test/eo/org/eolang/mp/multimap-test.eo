# MIT License
#
# Copyright (c) 2022 Eugene Darashkevich
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

+package org.eolang.mp
+alias org.eolang.txt.sprintf
+alias org.eolang.io.stdout
+alias org.eolang.mp.multimap
+junit

[] > multimap-pairs-to-hash-test
  multimap * > mp!
  * (* "key" 2) (* 2 3) (* 3 4) > arr!
  mp.pairs-to-hash arr > tarr!
  seq > @
    stdout
      sprintf
        "tarr size = %d\nvalues: %d %d %d\n"
        tarr.length
        tarr.at 0
        tarr.at 1
        tarr.at 2
    eq.
      tarr.at 2
      3

[] > multimap-concat-all-arrays-test
  multimap * > mp!
  * (* 1 2 3) (* 4 5 6 7) (* 8) (*) (* 9) (*) > arr!
  mp.concat-all-arrays arr > res!
  and. > @
    eq.
      res.length
      9
    eq.
      res.at 3
      4

[] > multimap-with-do-not-crashed
  multimap * > mp!
  (mp.with 1 2).with 3 4 > mp2!
  eq. > @
    mp2.length
    2

# Speed test
[] > multimap-with-many-objects
  multimap * > mp!
  with. > mp2!
    with.
      with.
        with.
          with.
            with.
              with.
                with.
                  with.
                    with.
                      mp
                      1
                      "a"
                    2
                    "b"
                  3
                  "c"
                4
                "d"
              5
              "e"
            6
            "f"
          7
          "g"
        8
        "h"
      9
      "i"
    10
    "j"
  eq. > @
    mp2.length
    10

[] > multimap-find-in-list-works
  multimap * > mp!
  * (* 1 2) (* "abc" "bca") (* "a" 42) > list!
  mp.find-in-list "abc" list > res!
  mp.find-in-list "c" list > res2!
  and. > @
    eq.
      res.length
      1
    eq.
      res2.length
      0

[] > multimap-find-do-not-crashed
  multimap * > mp!
  mp.find 1 > res!
  eq. > @
    res.length
    0

[] > multimap-find-works
  multimap (* (*) (* (* 4 "a")) (* (* 2 "c") (* 8 "c"))) > mp!
  mp.find 2 > r2!
  mp.find 3 > r3!
  mp.find 4 > r4!
  mp.find 8 > r8!
  and. > @
    eq.
      r2.at 0
      "c"
    eq.
      r3.length
      0
    eq.
      r4.at 0
      "a"
    eq.
      r8.at 0
      "c"

[] > multimap-find-and-with
  multimap * > fmp!
  ((((fmp.with 1 "a").with "abc" "cba").with 4 5).with 3 5) > mp!
  mp.find 1 > r1!
  mp.find 2 > r2!
  mp.find 3 > r3!
  mp.find 4 > r4!
  mp.find "abc" > rabc!
  and. > @
    eq.
      r1.at 0
      "a"
    eq.
      r2.length
      0
    eq.
      r3.at 0
      5
    eq.
      r4.at 0
      5
    eq.
      rabc.at 0
      "cba"

[] > multimap-of-multimaps
  multimap * > init-mp!
  (init-mp.with 1 2).with 3 4 > mp1!
  (init-mp.with "a" "b").with "c" "d" > mp2!
  init-mp.with TRUE FALSE > mp3!
  ((init-mp.with 0 mp1).with 1 mp2).with 2 mp3 > mp-res!
  and. > @
    eq.
      (mp-res.find -1).length
      0
    eq.
      (((mp-res.find 1).at 0).find "c").at 0
      "d"

[] > multimap-without-works
  multimap * > init-mp!
  (((init-mp.with 1 "a").with 3 "c").with 2 "b").with 4 "d" > mp!
  (mp.without 2).without 3 > mp2!
  and. > @
    eq.
      (mp.find 1).length
      1
    eq.
      (mp.find 2).length
      1
    eq.
      (mp2.find 3).length
      0
    eq.
      (mp2.find 4).length
      1

[] > multimap-without-many-elements
  multimap * > init-mp!
  ((init-mp.with 1 "a").with 2 "b").with 1 "c" > mp!
  mp.without 1 > mp2!
  and. > @
    eq.
      mp.length
      3
    eq.
      mp2.length
      1
